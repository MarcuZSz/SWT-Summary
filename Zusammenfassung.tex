\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}     
\usepackage[T1]{fontenc}
\usepackage[german]{babel}     
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{lmodern}          
\usepackage{float}              
\usepackage{caption}  
\usepackage{adjustbox}
\usepackage[hidelinks]{hyperref}
\bibliographystyle{plain}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}      

\captionsetup[figure]{name=Abb.}
\setcounter{secnumdepth}{5}     
\setcounter{tocdepth}{5}        

\begin{document}

\tableofcontents
\newpage

\section{Softwareprozesse}

\subsection{Vorgehensmodelle}

\subsubsection{Wasserfallmodell}

\begin{figure}[H]

\centering

\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item lineares, plangetriebenes Modell mit aufeinanderbauenden Phasen
\item typische Phasen:
\begin{enumerate}
\item Anforderungsanalyse
\item System- \& Softwareentwurf
\item Implementierung \& Modultests
\item Integration \& Systemtest
\item Betrieb \& Wartung
\end{enumerate}
\item Vorteile: klare Struktur, gut dokumentiert, geeignet für sicherheitskritische Systeme
\item Nachteile: Änderungen sind teuer, spätes Feedback, kaum Flexibilität
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\vspace{20mm}
\adjustbox{valign=c}{\includegraphics[scale=0.45]{pictures/Wasserfallmodell.png}}
\caption{Wasserfallmodell}
\end{minipage}
\end{figure}

\subsubsection{Inkrementelle Entwicklung}

\begin{itemize}
\item Spezifikation, Entwicklung \& Validierung laufen parallel.
\item Software wird in aufeinander aufbauenden Inkrementen geliefert.
\item Jedes Inkrement liefert nutzbare Funktionalität.
\item Vorteile: Frühe Auslieferung, Kundenfeedback möglich, Anpassungen leichter
\item Nachteile: Mögliche Systemdegradation bei vielen Versionen, Management-Komplexität
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{pictures/inkrementelleImp.png}
\caption{Inkrementelle Entwicklung}
\end{figure}

\subsubsection{Integration \& Konfiguration}

\begin{itemize}
\item Nutzt bestehende Komponenten oder Systeme.
\item Phasen:
\begin{enumerate}
\item Anforderungsspezifikation
\item Komponenten-/Softwareerkennung \& -evaluierung
\item Anforderungsnachbesserung
\item Anpassen \& Integration von Komponenten
\item Konfiguration des Anwendungssystems
\end{enumerate}
\item Vorteile: Schnelle Lieferung, geringere Kosten und Risiken
\item Nachteile: Eingeschränkte Kontrolle, Kompromisse bei Anforderungen
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{pictures/integrationukonfig.png}
\caption{Wiederverwendungsorientiertes Software-Engineering}
\end{figure}

\subsection{Prozessaktivitäten}

\subsubsection{Softwarespezifikation}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item Definition der Funktionen und Beschränkungen des Systems
\item Ergebnis: Ein Anforderungsdokument, das zwischen Kunde \& Entwickler abgestimmt wird
\item Fehler hier sind kritisch, da sie später teuer werden
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=0.5]{pictures/softspezi.png}}
\caption{Ablauf der Anforderungsanalyse}
\end{minipage}
\end{figure}

\newpage

\subsubsection{Softwareentwurf \& -implementierung}

\begin{itemize}
\item Umsetzung der spezifizierten Anforderungen in ein ausführbares System
\item Umfasst Entwurf (Architektur, Komponenten) \& Implementierung (Programmierung)
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{pictures/softent-imp.png}
\caption{allgemeines Modell des Entwurfsprozesses}
\end{figure}

\subsubsection{Softwarevalidierung}
\begin{itemize}
\item Überprüfung, ob das System den Anforderungen und Benutzerbedürfnissen entspricht
\item Aktivitäten: Reviews, Tests, Abnahmen
\item Ziel: Qualitätssicherung \& Fehlererkennung vor Auslieferung
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.6]{pictures/softvali.png}
\caption{Testphasen}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.4]{pictures/softvali2.png}
\caption{Testphasen in plangesteuertem Softwareprozess}
\end{minipage}
\end{figure}

\newpage

\subsubsection{Weiterentwicklung von Software}
\begin{itemize}
\item Anpassung bestehender Software an neue Anforderungen, Technologien oder Umgebungen
\item Evolution kontinuierlich \& macht den Unterschied zwischen Entwicklung \& Wartung zunehmend unscharf
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{pictures/evosoft.png}
\caption{Weiterentwicklung eines Softwaresystems}
\end{figure}

\section{Clean Code I}

\subsection{Schlechter Code \& Folgen}

\begin{itemize}
\item entsteht durch Zeitdruck,  Nachlässigkeit oder fehlendes Verantwortungsbeswusstsein
\item führt zu technischer Schuldenbildung, wodurch Projekte immer langsamer \& teurer werden
\item chaotischer Code führt zu schlechter Wartung \& Gefahr Termine nicht einhalten zu können
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{pictures/ProdZeit.png}
\caption{Relation Prduktivität \& Zeit}
\end{figure}

\subsection{Clean Code schreiben}

\begin{itemize}
\item Übung macht den Meister
\item Gefühl für Code durch Erfahrung \& Refactoring
\item Code sollte elegant, klar \& lesbar sein
\end{itemize}

\subsection{Was ist Clean Code?}

\begin{itemize}
\item \textbf{Bjarne Stroustrup (C++):}
\begin{itemize}
\item Code soll elegant, effizient, gradlinig \& wartbar sein
\item Sorgfalt im Detail (Fehlerbehandlung, Namensgebung, minimale Abhängigkeiten)
\item Sauberer Code erledigt eine Aufgabe gut
\end{itemize}
\item \textbf{Grady Booch:}
\begin{itemize}
\item Sauberer Code ist einfach, direkt \& liest sich wie Prosa
\item zeigt klar die Absicht des Entwicklers
\end{itemize}
\item \textbf{Dave Thomas (The Pragmatic Programmer):}
\begin{itemize}
\item Code soll von anderen gelesen, verstanden \& verbessert werden können
\item Unit-Tests sind unverzichtbar – Code ohne Tests ist nicht sauber
\item Klein \&literate: Code muss für Menschen lesbar sein
\end{itemize}
\item \textbf{Michael Feathers:}
\begin{itemize}
\item Sauberer Code zeigt Mühe
\item erkennt Sorgfalt \& Bewusstsein für Qualität
\end{itemize}
\item \textbf{Ron Jeffries:}
\begin{itemize}
\item Einfacher Code erfüllt vier Regeln:
\begin{enumerate}
\item Besteht alle Tests
\item Enthält keine Duplizierungen
\item Drückt alle Designideen klar aus
\item Minimiert die Anzahl der Entitäten (Klassen, Methoden etc.)
\end{enumerate}
\end{itemize}
\item \textbf{Ward Cunningham:}
\begin{itemize}
\item Sauberer Code verhält sich genau so, wie man es erwartet, ohne Überraschungen
\item Lesbar, offensichtlich \& elegant
\end{itemize}
\end{itemize}

\subsection{Weitere Prinzipien}

\begin{itemize}
\item \textbf{Pfadfinder-Regel:} \\
„Hinterlasse den Code sauberer, als du ihn vorgefunden hast.“ \\
$\rightarrow$ Kleine, kontinuierliche Verbesserungen verhindern Verfall.
\item \textbf{Wir sind Autoren!:} \\
Code ist eine Form von Kommunikation. \\
$\rightarrow$ Schreibe Code für Menschen, nicht für Maschinen.
\item \textbf{Vorläufer \& Prinzipien:} \\
Sauberer Code folgt bekannten Designprinzipien wie
\begin{itemize}
\item SRP (Single Responsibility Principle)
\item OCP (Open-Closed Principle)
\item DIP (Dependency Inversion Principle)
\end{itemize}
\end{itemize}

\subsection{Kerngedanke Clean Code}

\begin{itemize}
\item Sauberer Code ist leicht zu lesen, zu verstehen \& zu ändern.
\item Er ist einfach, elegant, klar strukturiert und getestet.
\item Klein ist besser, jede Funktion, Klasse \& Methode erfüllt eine Aufgabe.
\item Sauberkeit entsteht durch Sorgfalt, Disziplin \& Verantwortung.
\end{itemize}

\section{Projektmanagement \& -planung}

\subsection{Risikomanagment}

Risikomanagement ist die zentrale Aufgabe eines Softwareprojektmanagers. Es geht darum, Risiken frühzeitig zu erkennen, zu analysieren, zu planen \& zu überwachen, um Zeit- \& Qualitätsprobleme zu vermeiden. \\

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\textbf{Arten von Risiken}
\begin{itemize}
\item Projektrisiken: beeinflussen Zeitplan oder Ressourcen
\item Produktrisiken: betreffen Qualität \& Leistung der Software
\item Geschäftsrisiken: betreffen Unternehmen selbst
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-10mm}
\adjustbox{valign=c}{\includegraphics[scale=0.45]{pictures/bsprisman.png}}
\caption{Beispiele für Risiken}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{pictures/ablaufrisman.png}
\caption{Ablauf Risikomanagement}
\end{figure}

\subsubsection{Risikoerkennung}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item identifiziert mögl. Projekt-, Produkt- \& Geschäftsrisiken
\item durch Brainstorming, Checklists oder Erfahrung
\item 6 Risikoarten:
\begin{itemize}
\item technologisch
\item personenbezogen
\item unternehmensbezogen
\item Werkzeuge
\item Anforderungen
\item Schätzung
\end{itemize}
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{0mm}
\adjustbox{valign=c}{\includegraphics[scale=0.45]{pictures/bsprisarten.png}}
\caption{Beispiele Risikoarten}
\end{minipage}
\end{figure}

\subsubsection{Risikoanalyse}

\begin{itemize}
\item Eintrittswahrscheinlichkeit: sehr gering - sehr hoch
\item Auswirkung: unwesentlich, geringfügig, kritisch, katastrophal
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\centering
\includegraphics[scale=0.37]{pictures/risartenubsp.png}
\caption{Risikoarten \& Beispiele}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.45]{pictures/stratrisman.png}
\caption{Strategien zu Risikomanagement}
\end{minipage}
\end{figure}

\subsubsection{Risikoplanung}

\begin{itemize}
\item Vermeidungsstrategien: Verringern der Eintrittswahrscheinlichkeit des Risikos
\item Minimierungsstrategien: Auswirkungen des Risikos reduzieren
\item Notfallpläne: Einstellen auf schlimmsten Fall \& Strategie zur Problemlösung am besten bereits vorhanden
\end{itemize}

\subsubsection{Risikoüberwachung}

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{itemize}
\item kontinuierliche Überprüfung der Risiken
\item Anpassung von Plänen bei neuen Infos
\item iterativer Prozess während des gesamten Projekts
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=.45]{pictures/risindi.png}}
\caption{Risikoindikatoren}
\end{minipage}
\end{figure}

\subsection{Preiskalkulation Software}

Der Preis eines Softwareprojekts ergibt sich nicht nur aus den reinen Entwicklungskosten plus Gewinn, sondern hängt auch von wirtschaftlichen und vertraglichen Faktoren ab. \\

\noindent
\textbf{Einflussfaktoren für Softwarepreise}
\begin{itemize}
\item Marktchance: niedriger Preis, um neuen Markt zu gewinnen
\item Unsichere Kostenschätzung: Aufschlag zur Absicherung
\item Vertragsbedingungen: dem Entwickler Rechte vom Quellcode überlassen $\rightarrow$ Kostensenkung
\item Veränderliche Anforderungen: niedriger Einstiegspreis, bei Änderungen an Anforderungen Preiserhöhung möglich
\item Finanzlage: in Krisen Aufträge mit geringem Gewinn als keinen
\end{itemize}

\subsection{Plangesteuerte Entwicklung}

\textbf{Kernelemente:}
\begin{itemize}
\item frühzeitige, detaillierte Planung von Aufgaben, Ressourcen \& Zeit
\item Projektplan zur Steuerung, Kontrolle \& Kommunikation des Fortschritts
\item Planänderungen unvermeidlich, regelmäßiges Aktualisieren der Pläne
\end{itemize}
\noindent
\textbf{Vorteile:}
\begin{itemize}
\item frühzeitige Berücksichtigung von Ressourcen, Abhängigkeiten \& Risiken
\item klare Verantwortlichkeiten \& Messbarkeit des Fortschritts
\end{itemize}\noindent
\textbf{Nachteile:}
\begin{itemize}
\item Geringe Flexibilität bei sich ändernden Anforderungen
\item Gefahr übermäßiger Bürokratie
\end{itemize}
\noindent
große sicherheitskritische Systeme $\Rightarrow$ planbasiert \\
kleine dynamische Projekte $\Rightarrow$ agil

\subsubsection{Projektpläne}

\textbf{vollständiger Projektplan:}
\begin{enumerate}
\item Einleitung: Projektziele, Rahmenbedingungen (Budget, Zeit)
\item Projektorganisation: Teamstruktur \& Rollen
\item Risikoanalyse: potenzielle Risiken \& Gegenmaßnahmen
\item Hardware-/Softwareanforderungen: benötigte Ressourcen
\item Arbeitsaufteilung: Beschreibung der Aktivitäten, Eingaben \& Ergebnisse
\item Projektzeitplan: Abhängigkeiten, Meilensteine \& Personalzuordnung
\item Überwachung/Berichte: welche Berichte Management erstellt, wann erstellt \& was für Überwachungsmechanismen verwendet werden sollen
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/zupro.png}
\caption{Zusätzliche Projektpläne}
\end{figure}

\subsubsection{Planungsprozess}

\textbf{Schritte vom Planungsprozess(iterativ):}
\begin{enumerate}
\item Rahmenbedingungen festlegen (Budget, Tools, Termine)
\item Meilensteine \& Lieferobjekte bestimmen
\item Zeitplan entwerfen \& Aktivitäten starten
\item Fortschritt regelmäßig prüfen \& mit Plan abgleichen
\item Abweichungen analysieren \& Plan anpassen
\item bei gravierenden Problemen: Neuplanung, ggf. Neuverhandlung mit dem Kunden oder Projektabbruch
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/Projektplanungsprozess.png}
\caption{Projektplanungsprozess}
\end{figure}

\textbf{Wichtige Prinzipien}
\begin{itemize}
\item Realistische, nicht zu optimistische Annahmen
\item Zeitpuffer für unvorhergesehene Probleme
\item Iterative Überprüfung \& Anpassung
\item Dokumentation \& Kommunikation mit Stakeholdern
\end{itemize}

\section{Clean Code II}

\subsection{Funktionen}

\subsubsection{Größe \& Abstraktion}

\begin{itemize}
\item Funktionen sollen klein sein: wenige Zeilen, einheitlich eingerückt, gut lesbar
\item 1 Funktion = 1 Aufgabe: keine Mischung versch. Verantwortlichkeiten
\item 1 Abstraktionsebene pro Funktion: High-Level-Logik nicht mit Implementierungsdetails mischen
\item Code \glqq top down\grqq ~wie Geschichte lesbar
\end{itemize}

\subsubsection{Struktur \& Parameter}

\begin{itemize}
\item Switch-Anweisungen durch Polymorhpie/Vererbung ersetzen
\item für Leser verständliche Namen
\item wenige Parameter
\begin{itemize}
\item 1 ideal, 2 okay, 3 grenzwertig,  >3 schlecht
\item Flag vermeiden
\item wenn nötig Parameterobjekte nutzen
\end{itemize}
\end{itemize}

\subsubsection{Verhalten}

\begin{itemize}
\item keine Nebeneffekte
\item Anweisung \& Abfrage trennen
\item Exceptions statt Fehlercodes
\end{itemize}

\subsubsection{Saubere Umsetzung}

\begin{itemize}
\item \glqq Don't Repeat Yourself\grqq ~ (DRY-Prinzip)
\item nur 1 Eingangs- \& Ausgangspunkt pro Funktion
\item gute Funktionen durch Refactoring: zuerst funktional, dann aufräumen
\end{itemize}

\subsection{Objektet \& Strukturen}

\subsubsection{Datenabstraktion}

\begin{itemize}
\item Daten nicht über Getter/Setter direkt exponieren
\item lieber über Interfaces Verhalten, aber nicht Struktur, offenlegen
\end{itemize}

\subsubsection{Daten-/Objekte-Antisymmetrie}

\begin{itemize}
\item Objekte verbergen Daten, offenbaren Verhalten
\item Datenstrukturen enthüllen Daten, kein Verhalten
\item Objekte erleichtern Hinzufügen neuer Datentypen
\item Datenstrukturen erleichtern Hinzufügen neuer Funktionen
\end{itemize}

\subsubsection{Law of Demeter (LoD)}

\begin{itemize}
\item \glqq Mit Freunden, aber nicht mit Fremden sprechen!\grqq
\item keine lange Zugriffsketten (come().kneel().UsoDumb())
\item Lösung: sag was Objekt tun soll, nicht wie
\end{itemize}

\subsubsection{Datentransferobjekt (DTO)}

\begin{itemize}
\item einfacher Datencontainer (Felder, keine Logik)
\item Kommunikation zw. Systemschichten oder externes System
\item Active Records: Datenstruktur mit öffentlichen Variablen \\
$\rightarrow$ kein Stuff einfügen, dass es zu einem Objekt wird
\end{itemize}

\subsection{Klassen}

\subsubsection{Klassenaufbau}

\begin{itemize}
\item Klassen sollten beginnen mit:
\begin{enumerate}
\item public static Konstanten
\item private static Variablen
\item private Instanzvariablen
\item öffentliche Methoden, dann private Helfer
\end{enumerate}
\item alles möglichst privat, Tests über protected
\item public Variablen fast nie nötig
\end{itemize}

\subsubsection{Klassen sollten klein sein!}

\begin{itemize}
\item Kleinheit = wenige Verantwortlichkeiten
\item Faustregel: nur ein Grund zur Änderung $\rightarrow$ Single-Responsibility-Prinzip (SRP)
\item hohe Kohäsion: alle Methoden der Klasse dienen demselben Zweck
\item Gute Kohäsion führt zu vielen kleinen Klassen
\end{itemize}

\subsubsection{Änderungen planen}

\begin{itemize}
\item Änderungen isolieren: Strukturen so gestalten, dass Änderungen in einer Klasse nicht kaskadieren
\item Abhängigkeiten durch Interfaces oder Komposition minimieren
\end{itemize}

\newpage
\bibliography{sources}
\nocite{*}

\end{document}
