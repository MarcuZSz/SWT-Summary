\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}     
\usepackage[T1]{fontenc}
\usepackage[german]{babel}     
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{lmodern}          
\usepackage{float}              
\usepackage{caption}  
\usepackage{adjustbox}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\bibliographystyle{plain}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}  

\lstset{
  language=bash,
  basicstyle=\ttfamily\small,
  commentstyle=\color{gray},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  extendedchars=true,
  literate=
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {ü}{{\"u}}1
    {Ä}{{\"A}}1
    {Ö}{{\"O}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ã}{{\~a}}1
    {é}{{\'e}}1
} 

\captionsetup[figure]{name=Abb.}
\setcounter{secnumdepth}{5}     
\setcounter{tocdepth}{5}        

\begin{document}

\tableofcontents
\newpage

\section{Softwareprozesse}

\subsection{Vorgehensmodelle}

\subsubsection{Wasserfallmodell}

\begin{figure}[H]

\centering

\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item lineares, plangetriebenes Modell mit aufeinanderbauenden Phasen
\item typische Phasen:
\begin{enumerate}
\item Anforderungsanalyse
\item System- \& Softwareentwurf
\item Implementierung \& Modultests
\item Integration \& Systemtest
\item Betrieb \& Wartung
\end{enumerate}
\item Vorteile: klare Struktur, gut dokumentiert, geeignet für sicherheitskritische Systeme
\item Nachteile: Änderungen sind teuer, spätes Feedback, kaum Flexibilität
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\vspace{20mm}
\adjustbox{valign=c}{\includegraphics[scale=0.45]{pictures/Wasserfallmodell.png}}
\caption{Wasserfallmodell}
\end{minipage}
\end{figure}

\subsubsection{Inkrementelle Entwicklung}

\begin{itemize}
\item Spezifikation, Entwicklung \& Validierung laufen parallel.
\item Software wird in aufeinander aufbauenden Inkrementen geliefert.
\item Jedes Inkrement liefert nutzbare Funktionalität.
\item Vorteile: Frühe Auslieferung, Kundenfeedback möglich, Anpassungen leichter
\item Nachteile: Mögliche Systemdegradation bei vielen Versionen, Management-Komplexität
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{pictures/inkrementelleImp.png}
\caption{Inkrementelle Entwicklung}
\end{figure}

\subsubsection{Integration \& Konfiguration}

\begin{itemize}
\item Nutzt bestehende Komponenten oder Systeme.
\item Phasen:
\begin{enumerate}
\item Anforderungsspezifikation
\item Komponenten-/Softwareerkennung \& -evaluierung
\item Anforderungsnachbesserung
\item Anpassen \& Integration von Komponenten
\item Konfiguration des Anwendungssystems
\end{enumerate}
\item Vorteile: Schnelle Lieferung, geringere Kosten und Risiken
\item Nachteile: Eingeschränkte Kontrolle, Kompromisse bei Anforderungen
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{pictures/integrationukonfig.png}
\caption{Wiederverwendungsorientiertes Software-Engineering}
\end{figure}

\subsection{Prozessaktivitäten}

\subsubsection{Softwarespezifikation}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item Definition der Funktionen und Beschränkungen des Systems
\item Ergebnis: Ein Anforderungsdokument, das zwischen Kunde \& Entwickler abgestimmt wird
\item Fehler hier sind kritisch, da sie später teuer werden
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=0.5]{pictures/softspezi.png}}
\caption{Ablauf der Anforderungsanalyse}
\end{minipage}
\end{figure}

\newpage

\subsubsection{Softwareentwurf \& -implementierung}

\begin{itemize}
\item Umsetzung der spezifizierten Anforderungen in ein ausführbares System
\item Umfasst Entwurf (Architektur, Komponenten) \& Implementierung (Programmierung)
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{pictures/softent-imp.png}
\caption{allgemeines Modell des Entwurfsprozesses}
\end{figure}

\subsubsection{Softwarevalidierung}
\begin{itemize}
\item Überprüfung, ob das System den Anforderungen und Benutzerbedürfnissen entspricht
\item Aktivitäten: Reviews, Tests, Abnahmen
\item Ziel: Qualitätssicherung \& Fehlererkennung vor Auslieferung
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.6]{pictures/softvali.png}
\caption{Testphasen}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.4]{pictures/softvali2.png}
\caption{Testphasen in plangesteuertem Softwareprozess}
\end{minipage}
\end{figure}

\newpage

\subsubsection{Weiterentwicklung von Software}
\begin{itemize}
\item Anpassung bestehender Software an neue Anforderungen, Technologien oder Umgebungen
\item Evolution kontinuierlich \& macht den Unterschied zwischen Entwicklung \& Wartung zunehmend unscharf
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{pictures/evosoft.png}
\caption{Weiterentwicklung eines Softwaresystems}
\end{figure}

\section{Clean Code I}

\subsection{Schlechter Code \& Folgen}

\begin{itemize}
\item entsteht durch Zeitdruck,  Nachlässigkeit oder fehlendes Verantwortungsbeswusstsein
\item führt zu technischer Schuldenbildung, wodurch Projekte immer langsamer \& teurer werden
\item chaotischer Code führt zu schlechter Wartung \& Gefahr Termine nicht einhalten zu können
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{pictures/ProdZeit.png}
\caption{Relation Prduktivität \& Zeit}
\end{figure}

\subsection{Clean Code schreiben}

\begin{itemize}
\item Übung macht den Meister
\item Gefühl für Code durch Erfahrung \& Refactoring
\item Code sollte elegant, klar \& lesbar sein
\end{itemize}

\subsection{Was ist Clean Code?}

\begin{itemize}
\item \textbf{Bjarne Stroustrup (C++):}
\begin{itemize}
\item Code soll elegant, effizient, gradlinig \& wartbar sein
\item Sorgfalt im Detail (Fehlerbehandlung, Namensgebung, minimale Abhängigkeiten)
\item Sauberer Code erledigt eine Aufgabe gut
\end{itemize}
\item \textbf{Grady Booch:}
\begin{itemize}
\item Sauberer Code ist einfach, direkt \& liest sich wie Prosa
\item zeigt klar die Absicht des Entwicklers
\end{itemize}
\item \textbf{Dave Thomas (The Pragmatic Programmer):}
\begin{itemize}
\item Code soll von anderen gelesen, verstanden \& verbessert werden können
\item Unit-Tests sind unverzichtbar – Code ohne Tests ist nicht sauber
\item Klein \&literate: Code muss für Menschen lesbar sein
\end{itemize}
\item \textbf{Michael Feathers:}
\begin{itemize}
\item Sauberer Code zeigt Mühe
\item erkennt Sorgfalt \& Bewusstsein für Qualität
\end{itemize}
\item \textbf{Ron Jeffries:}
\begin{itemize}
\item Einfacher Code erfüllt vier Regeln:
\begin{enumerate}
\item Besteht alle Tests
\item Enthält keine Duplizierungen
\item Drückt alle Designideen klar aus
\item Minimiert die Anzahl der Entitäten (Klassen, Methoden etc.)
\end{enumerate}
\end{itemize}
\item \textbf{Ward Cunningham:}
\begin{itemize}
\item Sauberer Code verhält sich genau so, wie man es erwartet, ohne Überraschungen
\item Lesbar, offensichtlich \& elegant
\end{itemize}
\end{itemize}

\subsection{Weitere Prinzipien}

\begin{itemize}
\item \textbf{Pfadfinder-Regel:} \\
„Hinterlasse den Code sauberer, als du ihn vorgefunden hast.“ \\
$\rightarrow$ Kleine, kontinuierliche Verbesserungen verhindern Verfall.
\item \textbf{Wir sind Autoren!:} \\
Code ist eine Form von Kommunikation. \\
$\rightarrow$ Schreibe Code für Menschen, nicht für Maschinen.
\item \textbf{Vorläufer \& Prinzipien:} \\
Sauberer Code folgt bekannten Designprinzipien wie
\begin{itemize}
\item SRP (Single Responsibility Principle)
\item OCP (Open-Closed Principle)
\item DIP (Dependency Inversion Principle)
\end{itemize}
\end{itemize}

\subsection{Kerngedanke Clean Code}

\begin{itemize}
\item Sauberer Code ist leicht zu lesen, zu verstehen \& zu ändern.
\item Er ist einfach, elegant, klar strukturiert und getestet.
\item Klein ist besser, jede Funktion, Klasse \& Methode erfüllt eine Aufgabe.
\item Sauberkeit entsteht durch Sorgfalt, Disziplin \& Verantwortung.
\end{itemize}

\section{Projektmanagement \& -planung}

\subsection{Risikomanagment}

Risikomanagement ist die zentrale Aufgabe eines Softwareprojektmanagers. Es geht darum, Risiken frühzeitig zu erkennen, zu analysieren, zu planen \& zu überwachen, um Zeit- \& Qualitätsprobleme zu vermeiden. \\

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\textbf{Arten von Risiken}
\begin{itemize}
\item Projektrisiken: beeinflussen Zeitplan oder Ressourcen
\item Produktrisiken: betreffen Qualität \& Leistung der Software
\item Geschäftsrisiken: betreffen Unternehmen selbst
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-10mm}
\adjustbox{valign=c}{\includegraphics[scale=0.45]{pictures/bsprisman.png}}
\caption{Beispiele für Risiken}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{pictures/ablaufrisman.png}
\caption{Ablauf Risikomanagement}
\end{figure}

\subsubsection{Risikoerkennung}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item identifiziert mögl. Projekt-, Produkt- \& Geschäftsrisiken
\item durch Brainstorming, Checklists oder Erfahrung
\item 6 Risikoarten:
\begin{itemize}
\item technologisch
\item personenbezogen
\item unternehmensbezogen
\item Werkzeuge
\item Anforderungen
\item Schätzung
\end{itemize}
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{0mm}
\adjustbox{valign=c}{\includegraphics[scale=0.45]{pictures/bsprisarten.png}}
\caption{Beispiele Risikoarten}
\end{minipage}
\end{figure}

\subsubsection{Risikoanalyse}

\begin{itemize}
\item Eintrittswahrscheinlichkeit: sehr gering - sehr hoch
\item Auswirkung: unwesentlich, geringfügig, kritisch, katastrophal
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\centering
\includegraphics[scale=0.37]{pictures/risartenubsp.png}
\caption{Risikoarten \& Beispiele}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.45]{pictures/stratrisman.png}
\caption{Strategien zu Risikomanagement}
\end{minipage}
\end{figure}

\subsubsection{Risikoplanung}

\begin{itemize}
\item Vermeidungsstrategien: Verringern der Eintrittswahrscheinlichkeit des Risikos
\item Minimierungsstrategien: Auswirkungen des Risikos reduzieren
\item Notfallpläne: Einstellen auf schlimmsten Fall \& Strategie zur Problemlösung am besten bereits vorhanden
\end{itemize}

\subsubsection{Risikoüberwachung}

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{itemize}
\item kontinuierliche Überprüfung der Risiken
\item Anpassung von Plänen bei neuen Infos
\item iterativer Prozess während des gesamten Projekts
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=.45]{pictures/risindi.png}}
\caption{Risikoindikatoren}
\end{minipage}
\end{figure}

\subsection{Preiskalkulation Software}

Der Preis eines Softwareprojekts ergibt sich nicht nur aus den reinen Entwicklungskosten plus Gewinn, sondern hängt auch von wirtschaftlichen und vertraglichen Faktoren ab. \\

\noindent
\textbf{Einflussfaktoren für Softwarepreise}
\begin{itemize}
\item Marktchance: niedriger Preis, um neuen Markt zu gewinnen
\item Unsichere Kostenschätzung: Aufschlag zur Absicherung
\item Vertragsbedingungen: dem Entwickler Rechte vom Quellcode überlassen $\rightarrow$ Kostensenkung
\item Veränderliche Anforderungen: niedriger Einstiegspreis, bei Änderungen an Anforderungen Preiserhöhung möglich
\item Finanzlage: in Krisen Aufträge mit geringem Gewinn als keinen
\end{itemize}

\subsection{Plangesteuerte Entwicklung}

\textbf{Kernelemente:}
\begin{itemize}
\item frühzeitige, detaillierte Planung von Aufgaben, Ressourcen \& Zeit
\item Projektplan zur Steuerung, Kontrolle \& Kommunikation des Fortschritts
\item Planänderungen unvermeidlich, regelmäßiges Aktualisieren der Pläne
\end{itemize}
\noindent
\textbf{Vorteile:}
\begin{itemize}
\item frühzeitige Berücksichtigung von Ressourcen, Abhängigkeiten \& Risiken
\item klare Verantwortlichkeiten \& Messbarkeit des Fortschritts
\end{itemize}\noindent
\textbf{Nachteile:}
\begin{itemize}
\item Geringe Flexibilität bei sich ändernden Anforderungen
\item Gefahr übermäßiger Bürokratie
\end{itemize}
\noindent
große sicherheitskritische Systeme $\Rightarrow$ planbasiert \\
kleine dynamische Projekte $\Rightarrow$ agil

\subsubsection{Projektpläne}

\textbf{vollständiger Projektplan:}
\begin{enumerate}
\item Einleitung: Projektziele, Rahmenbedingungen (Budget, Zeit)
\item Projektorganisation: Teamstruktur \& Rollen
\item Risikoanalyse: potenzielle Risiken \& Gegenmaßnahmen
\item Hardware-/Softwareanforderungen: benötigte Ressourcen
\item Arbeitsaufteilung: Beschreibung der Aktivitäten, Eingaben \& Ergebnisse
\item Projektzeitplan: Abhängigkeiten, Meilensteine \& Personalzuordnung
\item Überwachung/Berichte: welche Berichte Management erstellt, wann erstellt \& was für Überwachungsmechanismen verwendet werden sollen
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/zupro.png}
\caption{Zusätzliche Projektpläne}
\end{figure}

\subsubsection{Planungsprozess}

\textbf{Schritte vom Planungsprozess(iterativ):}
\begin{enumerate}
\item Rahmenbedingungen festlegen (Budget, Tools, Termine)
\item Meilensteine \& Lieferobjekte bestimmen
\item Zeitplan entwerfen \& Aktivitäten starten
\item Fortschritt regelmäßig prüfen \& mit Plan abgleichen
\item Abweichungen analysieren \& Plan anpassen
\item bei gravierenden Problemen: Neuplanung, ggf. Neuverhandlung mit dem Kunden oder Projektabbruch
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/Projektplanungsprozess.png}
\caption{Projektplanungsprozess}
\end{figure}

\textbf{Wichtige Prinzipien}
\begin{itemize}
\item Realistische, nicht zu optimistische Annahmen
\item Zeitpuffer für unvorhergesehene Probleme
\item Iterative Überprüfung \& Anpassung
\item Dokumentation \& Kommunikation mit Stakeholdern
\end{itemize}

\subsection{Netzplan}

\begin{itemize}
\item obere Zeile: frühestmögliche Zeitpunkte, von vorne nach hinten
\item linke Spalte: Start, Mitte: benötigte Zeit (oben)/Puffer (unten), rechte Spalte: Ende
\item untere Zeile: spätestmögliche Zeitpunkte, von hinten nach vorne
\item jeweils höhere Zeit als nächsten Startwert/Endwert nehmen
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.7]{pictures/netzplan.png}
\caption{Aufgabe 1 aus Übungsblatt 4}
\end{figure}

\newpage

\subsection{Gantt-Charts}

\begin{itemize}
\item prüfe Abhängigkeiten
\item voneinander unabhängige Aufgaben können gleichzeitig starten
\item kritische Pfade: umfasst Arbeitspakete, deren Dauer den Projektendtermin bestimmt; jede Verzögerung in einem dieser Pakete verlängert die gesamte Projektdauer
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/gantt.png}
\caption{Aufgabe 2 aus Übungsblatt 4}
\end{figure}

\section{Clean Code II}

\subsection{Funktionen}

\subsubsection{Größe \& Abstraktion}

\begin{itemize}
\item Funktionen sollen klein sein: wenige Zeilen, einheitlich eingerückt, gut lesbar
\item 1 Funktion = 1 Aufgabe: keine Mischung versch. Verantwortlichkeiten
\item 1 Abstraktionsebene pro Funktion: High-Level-Logik nicht mit Implementierungsdetails mischen
\item Code \glqq top down\grqq ~wie Geschichte lesbar
\end{itemize}

\subsubsection{Struktur \& Parameter}

\begin{itemize}
\item Switch-Anweisungen durch Polymorhpie/Vererbung ersetzen
\item für Leser verständliche Namen
\item wenige Parameter
\begin{itemize}
\item 1 ideal, 2 okay, 3 grenzwertig,  >3 schlecht
\item Flag vermeiden
\item wenn nötig Parameterobjekte nutzen
\end{itemize}
\end{itemize}

\subsubsection{Verhalten}

\begin{itemize}
\item keine Nebeneffekte
\item Anweisung \& Abfrage trennen
\item Exceptions statt Fehlercodes
\end{itemize}

\subsubsection{Saubere Umsetzung}

\begin{itemize}
\item \glqq Don't Repeat Yourself\grqq ~ (DRY-Prinzip)
\item nur 1 Eingangs- \& Ausgangspunkt pro Funktion
\item gute Funktionen durch Refactoring: zuerst funktional, dann aufräumen
\end{itemize}

\subsection{Objekte \& Strukturen}

\subsubsection{Datenabstraktion}

\begin{itemize}
\item Daten nicht über Getter/Setter direkt exponieren
\item lieber über Interfaces Verhalten, aber nicht Struktur, offenlegen
\end{itemize}

\subsubsection{Daten-/Objekte-Antisymmetrie}

\begin{itemize}
\item Objekte verbergen Daten, offenbaren Verhalten
\item Datenstrukturen enthüllen Daten, kein Verhalten
\item Objekte erleichtern Hinzufügen neuer Datentypen
\item Datenstrukturen erleichtern Hinzufügen neuer Funktionen
\end{itemize}

\subsubsection{Law of Demeter (LoD)}

\begin{itemize}
\item \glqq Mit Freunden, aber nicht mit Fremden sprechen!\grqq
\item keine lange Zugriffsketten (come().kneel().UsoDumb())
\item Lösung: sag was Objekt tun soll, nicht wie
\end{itemize}

\subsubsection{Datentransferobjekt (DTO)}

\begin{itemize}
\item einfacher Datencontainer (Felder, keine Logik)
\item Kommunikation zw. Systemschichten oder externes System
\item Active Records: Datenstruktur mit öffentlichen Variablen \\
$\rightarrow$ kein Stuff einfügen, dass es zu einem Objekt wird
\end{itemize}

\subsection{Klassen}

\subsubsection{Klassenaufbau}

\begin{itemize}
\item Klassen sollten beginnen mit:
\begin{enumerate}
\item public static Konstanten
\item private static Variablen
\item private Instanzvariablen
\item öffentliche Methoden, dann private Helfer
\end{enumerate}
\item alles möglichst privat, Tests über protected
\item public Variablen fast nie nötig
\end{itemize}

\subsubsection{Klassen sollten klein sein!}

\begin{itemize}
\item Kleinheit = wenige Verantwortlichkeiten
\item Faustregel: nur ein Grund zur Änderung $\rightarrow$ Single-Responsibility-Prinzip (SRP)
\item hohe Kohäsion: alle Methoden der Klasse dienen demselben Zweck
\item Gute Kohäsion führt zu vielen kleinen Klassen
\end{itemize}

\subsubsection{Änderungen planen}

\begin{itemize}
\item Änderungen isolieren: Strukturen so gestalten, dass Änderungen in einer Klasse nicht kaskadieren
\item Abhängigkeiten durch Interfaces oder Komposition minimieren
\end{itemize}

\section{Software Engineering}

\subsection{Agile Methoden}

Agile Methoden funktionieren gut für kleine, zusammenarbeitende Teams, die nicht stark abhängig von anderen Systemen oder Abteilungen sind. Beispiele sind Scrum, Extreme Programming (XP) \& DSDM. 

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Agiles Manifest} \\
Bevorzugt werden:
\begin{itemize}
\item Individuen \& Interaktionen über Prozesse \& Werkzeuge
\item Funktionierend Software über Dokumentation
\item Zusammenarbeit mit dem Kunden über Vertragsverhandlungen
\item Reaktion auf Veränderung über strikte Planverfolgung
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-5mm}
\includegraphics[scale=.35]{pictures/agilemeth.png}
\caption{Gemeinsame Prinzipien agiler Methoden}
\end{minipage}
\end{figure}

\subsection{Techniken der agilen Entwicklung}

Prägendstes agiles Modell ist Extreme Programming (XP), wo Praktiken extrem umgesetzt werden, z.B. sehr häufige Releases oder intensives Testen.

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/xprelease.png}
\caption{XP-Releasezyklus}
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.31]{pictures/xp1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.37]{pictures/xp2.png}
\end{minipage}
\caption{Prinzipien \& Verfahren des XP}
\end{figure}

\subsubsection{User-Storys}

\begin{itemize}
\item Anfoderungen wernden nicht als langes Dokument beschrieben, sondern als kurze Nutzerszenarien (\glqq User-Storys\grqq)
\item Werden auf Story-Cards festgehalten \& später in Tasks heruntergebrochen
\item Kunde priorisiert Stories \& entscheidet, welche in nächsten Release gelangen
\item Problem: Vollständigkeit der Stories schwer zu überprüfen
\end{itemize}

\subsubsection{Refactoring}

\begin{itemize}
\item statt zukünfige Änderungen vordenken, Code laufend verbessern
\item Ziel: Vermeidung von Code-Verfall (duplicated code, schlechte Struktur)
\item Bsp.: Umbenennungen, Vereinfachungen, Entfernen von Duplikaten
\item Risiko: Zeitdruck kann dazu führen, dass Refactoring zu spät stattfindet
\end{itemize}

\newpage

\subsubsection{Test-First-Entwicklung}

\begin{itemize}
\item Tests vor Code geschrieben
\item Vorteile:
\begin{itemize}
\item Anforderungen müssen klar sein
\item Probleme werden früh erkannt
\item vermeidet Testverzug
\end{itemize}
\item Tests auf Basis der Tasks aus den User-Storys
\item automatisierte Tests (z.B. JUnit) essentiell
\item Probleme:
\begin{itemize}
\item Entwickler schreiben ungerne Tests $\rightarrow$ Risiko unvollständiger Testabdeckung
\item UI-Tests schwer automatisierbar
\end{itemize}
\end{itemize}

\subsubsection{Pair Programming}

\begin{itemize}
\item 2 Entwickler an einem Arbeitsplatz
\item Vorteile:
\begin{enumerate}
\item höhere Codequality durch unmittelbare Kontrolle
\item Wissen wird geteilt
\item fördert Refactoring \& Verantwortungsbewusstsein
\end{enumerate}
\item Nachteile:
\begin{enumerate}
\item geringere Produktivität bei erfahrenen Entwicklern (zeigen Studien)
\item Unternehmen nutzt Pair Programming daher punktuell
\end{enumerate}
\end{itemize}

\subsection{Agiles Projektmanagement}

Scrum bietet einen organisatorischen Rahmen für agile Projekte, ohne zwingend XP-Praktiken zu verlangen. Scrum unterstützt Transparenz, schnelle Rückmeldung \& kontinuierliche Verbesserung. Herausforderungen sind v. a. verteilte Teams, weshalb Varianten wie Distributed Scrum existieren.\\
\\
\textbf{Zentrale Elemente von Scrum}

\begin{itemize}
\item \textbf{Product Owner:} priorisiert Anfoderungen im Product Backlog
\item \textbf{Developemnet Team:} max. 7 Personen, selbstorganisiert
\item \textbf{ScrumMaster:} achtet auf Einhaltung von Scrum, schützt Team
\item \textbf{Sprint:} Iteration von 2 bis 4 Wochen
\item \textbf{Daily Scrum:} kurzes tägliches Meeting
\item \textbf{Sprint Review:} Bewertung des erzielten Inkrements \& Prozessverbesserung
\item \textbf{Velocity:} Maß für Teamleistung zur Planung kommender Sprints
\item \textbf{Product Backlog:} TO-DO-List zum abarbeiten
\item \textbf{Potentially Shippable Product Increment:} potenziell auslieferbar, eig keine weiteren Tests nötig, Zeit zur Integration ins finale Produkt \\
$\Rightarrow$ nicht immer möglich
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.4]{pictures/sprintzyklus.png}
\caption{Sprint-Zyklus von Scrum}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/disscrum.png}
\caption{Distributed Scrum}
\end{minipage}
\end{figure}

\section{Was ist KANBAN?}

Kanban ist eine Methode, um Services für Wissensarbeit sichtbar zu machen, zu managen und zu verbessern. Sie basiert darauf, mit dem zu starten, was bereits existiert, und Veränderung evolutionär vorzunehmen. \\
Zentral ist die Visualisierung von Arbeit und die Begrenzung paralleler Arbeit (WIP) durch ein Kanban-System, wodurch ein Pull-System entsteht: Neue Arbeit wird erst begonnen, wenn Kapazität frei wird. \\
Der Fokus liegt auf der Serviceerbringung – Arbeit fließt von der Anfrage über mehrere Prozessschritte bis zur Lieferung.

\subsection{KANBAN-Werte}

\begin{itemize}
\item Transparenz: offener Informationsaustausch, klares Vokabular
\item Balance: nachhaltiges Ausbalancieren von Fähigkeiten, Nachfrage \& Prioritäten
\item Kollaboration: gemeinsame Problemlösung
\item Kundenfokus: Arbeit muss Wert für den Kunden erzeugen
\item Arbeitsfluss: Arbeit bewegt sich kontinuierlich durch den Prozess
\item Führung: jeder kann verbessern \& Verantwortung übernehmen
\item Verständnis: Selbsterkenntnis über Stärken/Schwächen von Team/Organisation
\item Vereinbarung: gemeinsames Commitment zu Zielen \& Verbesserungen
\item Respekt: Grundwert, Basis für alle anderen
\end{itemize}

\subsection{Die KANBAN-Agenden}

\textbf{Nachhaltigkeit}
\begin{itemize}
\item Ziel: Überlastung reduzieren, Arbeitskapazität \& Nachfrage ausbalancieren
\item führt zu besserer Qualität, Zufriedenheit, Tempo \& Zusammenarbeit
\end{itemize}
\noindent
\textbf{Serviceorientierung}
\begin{itemize}
\item Fokus auf wertorientierte Services für Kunden
\item Ziel: Lieferungen passend zum Zweck (\glqq fit for purpose\grqq)
\item Kundenbedürfnisse im Zentrum aller Entscheidungen
\end{itemize}
\noindent
\textbf{Überlebensfähigkeit}
\begin{itemize}
\item Ziel: Organisation anpassungsfähig \& konkurrenzfähig halten
\item evolutionäre Veränderung als Antwort auf Marktveränderungen \& Disruption
\item Förderung von Experimenten, kontinuierlichem Lernen, Vielfalt \& Resilienz
\end{itemize}

\subsection{Grundprinzipien von KANBAN}

\subsubsection{Charge-Management-System}

\begin{itemize}
\item Beginne mit dem, was du gerade tust: existierende Rollen, Prozesse, Titel respektieren
\item Evolutionäre Veränderung vereinbaren: kleine, risikoarme Schritte
\item Führung auf allen Ebenen fördern: jeder trägt zur Verbesserung bei
\end{itemize}

\subsubsection{Service-Delivery-Prinzipien}

\begin{itemize}
\item Kundenbedürfnisse verstehen \& fokussieren
\item Arbeit managen, Menschen sich selbst organisieren lassen
\item Regeln entwickeln, um bessere Ergebnisse zu liefern
\end{itemize}

\subsection{Beschreibung von Arbeitsflusssystemen}

\begin{itemize}
\item beschreibt ein System aus Arbeitseinheiten, die durch Prozessschritte fließen
\item notwendige Elemente:
\begin{itemize}
\item Commitment Point (Zusage)
\item Delivery Point (Fertige Lieferung)
\item WIP-Limits (Work in Progress)
\end{itemize}
\item zentrale Metriken:
\begin{itemize}
\item Durchlaufzeit (Commitment → Lieferung)
\item Lieferrate/Durchsatz
\item WIP (parallele Arbeit)
\end{itemize}
\item \textbf{Little's Law:}
\begin{itemize}
\item $\bar{\text{Lieferrate}} = \frac{\bar{\text{WIP}}}{\bar{\text{Durchlaufzeit}}}$
\item alternativ: $\bar{\text{Durchsatz}} = \frac{\bar{\text{WIP}}}{\bar{\text{TIP}}}$
\item Kernbotschaft: weniger WIP $\Rightarrow$ schnellerer Flow
\end{itemize}
\item Unterscheidung zw. Systemdurchlaufzeit \& Kundendurchlaufzeit
\item macht Engpässe, Blocken \& Variabilität sichtbar
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.65]{pictures/kanbancfd.png}
\caption{kumulatives Flussdiagramm, womit man durch Division die Lieferrate berechnen kann}
\end{figure}

\subsection{Kernpraktiken von KANBAN}

\begin{enumerate}
\item \textbf{Visulisiere}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Darstellung von Arbeit, Prozessschritten \& Regeln (z. B. Kanban-Board)
\item Boards variieren stark; physisch oder digital
\item Wichtige Visualisierung: Blocker, Abhängigkeiten, Status
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-10mm}
\includegraphics[scale=.3]{pictures/kanbanraum.png}
\caption{Visualierung an Boards}
\end{minipage}
\end{figure}
\item \textbf{Limitiere parallele Arbeit (WIP)}
\begin{itemize}
\item Reduzierung teilfertiger Arbeit
\item Bessere Durchlaufzeiten, Qualität, Vorhersagbarkeit
\item Schafft Fokus und verhindert Überlastung
\item Macht Engpässe sichtbar
\end{itemize}
\item \textbf{Manage den Arbeitsfluss}
\begin{itemize}
\item Ziel: gleichmäßiger, schneller, vorhersehbarer Flow
\item Engpässe identifizieren und steuern
\item Fokus auf Kosten der Verzögerung (Cost of Delay)
\item Nutzung verschiedener Serviceklassen
\begin{figure}[H]
\centering
\includegraphics[scale=.7]{pictures/verzugkosten.png}
\caption{Verzögerungskostenprofile}
\end{figure}
\end{itemize}
\item \textbf{Mache Prozessregeln explizit}
\begin{itemize}
\item Klare Regeln für Workflow, Definition of Done, Replenishment, Serviceklassen usw
\item Regeln sichtbar, einfach, gemeinsam anpassbar
\item Grundlage für sinnvolle Experimente
\begin{figure}[H]
\centering
\includegraphics[scale=.7]{pictures/prozessregeln.png}
\caption{Prozessregeln für unterschiedliche Arbeitsschritte}
\end{figure}
\end{itemize}
\newpage
\item \textbf{Implementiere Rückkoplpungsschleifen}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Nutzung regelmäßiger Kadenzen/Meetings für:
\begin{itemize}
\item Strategie: Festlegen anzubietender Services
\item Operations: Balance zw. Service \& Kundenerwartung
\item Risiko
\item Service Delivery: Überprüfung \& Verbesserung
\item Replenishment
\item tägliches Kanban-Meeting
\item Delivery-Planung: Überwachung \& Planung der Auslieferung
\end{itemize}
\item Feedback ermöglicht Anpassung \& Verbesserung
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{5mm}
\includegraphics[scale=.3]{pictures/sk.png}
\caption{Satz von Kadenzen zeigt Rückkopplungsschleifen}
\end{minipage}
\end{figure}
\item \textbf{Verbessere gemeinsam \& entwickle experimentell weiter}
\begin{itemize}
\item kontinuierliche, evolutionäre Veränderung
\item Experimente \& Hypothesen testen (wissenschaftliche Methode)
\item Positive Veränderungen verstärken, negative zurücknehmen
\item Auf Veränderung im Umfeld reagieren (Fit-for-Purpose)
\end{itemize}
\end{enumerate}

\section{Versionskontrolle für Dumme}

\subsection{Was ist Git?}

\textbf{Die wichtigsten Git-Konzepte}
\begin{itemize}
\item Repository (Repo): Projektordner mit Code, Historie \& Konfiguration
\item Commit: Eine gespeicherte Änderung am Projekt (mit Nachricht)
\item Branch: Eine parallele Entwicklungslinie, z. B. main, dev, feature/login
\item Merge: Änderungen eines Branches in einen anderen integrieren
\item Remote: Online-Version eines Repos, z. B. auf GitLab
\item Clone \& Pull: Repo herunterladen bzw. aktualisieren
\item Push: Lokale Änderungen ins Remote hochladen
\end{itemize}

\subsection{Git-CLI (Command Line Interface)}

\begin{lstlisting}[language=bash]
# lokales Git-Repo im Ordner
git init

# Zeigt alle Änderungen (tracked/untracked)
git status

# Änderungen zum Staging hinzufügen
git add <datei>
# oder alles
git add .

# Commit erstellen
git commit -m "..."
# ausführlicherer Commit
git commit

# neuen Branch erstellen
git branch feature-login

# zum Branch wechseln
git checkout feature-login

# Branch erstellen & wechseln
git checkout -b feature-login

# Branches mergen, lieber mit GitHub oder GitLab
git checkout main
git merge feature-login

# Remote Repo
git clone https://gitlab.com/user/repo.git
git remote add origin https://gitlab.com/user/repo.git

# Änderungen hochladen
git push -u origin main

# aktuelle Daten runterladen
git pull
\end{lstlisting}

\subsection{GitLab Überblick}

\textbf{Wichtige GitLab-Funktionen}
\begin{itemize}
\item Remote-Repository: Gemeinsame Online-Version des Projekts
\item Issues: Aufgaben, Tickets, Bug-Tracking
\item Merge Requests (MRs): Code-Änderungen prüfen \& freigeben (Code Reviews)
\item CI/CD Pipelines: Automatische Tests, Builds und Deployments
\item Wikis \& Dokumentation: Projektdokumentation im Repo
\item Access Control / Permissions: Rollen wie Developer, Maintainer
\item Projektgruppen \& Visibility Settings: Organisation von Teams \& Rechten
\end{itemize}

\section{Personalmanagement und Teamarbeit}

\subsection{Personalmanagement}

\textbf{Zentrale Prinzipien im Umgang mit Mitarbeitenden}
\begin{enumerate}
\item \textbf{Gleichheit} \\
Alle Teammitglieder sollen fair behandelt werden, niemand soll das Gefühl haben, weniger wertgeschätzt zu werden.
\item \textbf{Respekt} \\
Individuelle Fähigkeiten anerkennen; jeder soll die Chance haben, seinen Beitrag zu leisten.
\item \textbf{Integration} \\
Mitarbeitende sollten das Gefühl haben, dass ihre Vorschläge ernst genommen werden und sie Teil der Gruppe sind. 
\item \textbf{Ehrlichkeit} \\
Offene Kommunikation über Probleme, Stärken und Schwächen; Manager sollen eigene Wissenslücken zugeben.
\end{enumerate}

\noindent
\textbf{Mitarbeiter motivieren}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Maslows Bedürfnishierarchie}
\begin{itemize}
\item Soziale Bedürfnisse: Möglichkeit für Austausch, informelle Treffen, Räume für Begegnung
\item Anerkennung: Wertschätzung, faire Bezahlung, öffentliches Lob
\item Selbstverklichung: Verantwortung übernehmen, anspruchsvolle Aufgaben, Weiterbildung
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\textbf{Motivationstypen nach Bass \& Duntemann}
\begin{itemize}
\item Aufgabenorientiert: Motivation durch die technische Herausforderung
\item Selbstorientiert: Motivation durch Karriereziele \& persönliche Anerkennung
\item Interaktionsorientiert: Motivation durch Zusammenarbeit \& Teamdynamik
\end{itemize}
\end{minipage}
\centering
\includegraphics[scale=.7]{pictures/bedürfnishierarchie.png}
\caption{Hirarchie menschlicher Bedürfnisse}
\end{figure}

\subsection{Teamwork}

\textbf{Wesentliche Eigenschaften erfolgreicher Teams}
\begin{itemize}
\item Software wird fast immer im Team entwickelt; Gruppen von 4–6 Personen ideal
\item Erfolgreiche Teams haben starken Zusammenhalt, gemeinsames Verantwortungsgefühl \& gegenseitige Unterstützung
\end{itemize}

\noindent
\textbf{Vorteile kohäsiver Teams}
\begin{itemize}
\item gemeinsame Qualitätsstandards entwickelt \& eingehalten
\item Wissen geteilt $\rightarrow$ Ausfälle sind weniger kritisch
\item Lernen voneinander, offene Fehlerkultur
\item Förderung von Verbesserung \& Refactoring
\end{itemize}

\noindent
Manager sollen Maßnahmen ergreifen, um Teamkohäsion zu fördern, z. B. regelmäßige Treffen, gemeinsame Aktivitäten, offene Informationspolitik.

\subsubsection{Auswahl der Teammitglieder}

Bei der Teamzusammenstellung zählen nicht nur Fähigkeiten, sondern auch Persönlichkeitstypen \& Motivation.

\begin{itemize}
\item Entwickler oft mit eigenen Lösungsansätzen $\rightarrow$ potenzielle Konflikte
\item unterschiedliche Motivationstypen ergänzen sich \& reduzieren Konkurrenzverhalten
\item interaktionsorientierte Personen besonders wichtig für Teamklima
\item perfekte Zusammensetzung nicht möglich, Manager muss Konflikte früh erkennen \& steuern.
\end{itemize}

\subsubsection{Organisation der Gruppe}

Die Gruppenorganisation beeinflusst Entscheidungswege, Kommunikation und Zusammenarbeit.

\begin{itemize}
\item Soll der Projektmanager auch technischer Leiter sein? \\
$\rightarrow$ In großen Projekten eher trennen.
\item Wie werden Verantwortlichkeiten verteilt?
\item Wie wird interne \& externe Kommunikation gestaltet?
\end{itemize}

\subsubsection{Kommunikation im Team}

Kommunikation ist ein kritischer Erfolgsfaktor.

\begin{itemize}
\item regelmäßige Teammeetings \& Reviews
\item klar definierte Kommunikationswege
\item vollständige Information für alle Teammitglieder
\item offener Austausch zwischen Team, Management \& Stakeholdern
\end{itemize}

\newpage
\bibliography{sources}
\nocite{*}

\end{document}
